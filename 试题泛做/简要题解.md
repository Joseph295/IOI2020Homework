##### AGC020D Min Max Repetition

最终串一点是前半部分 $k$ 个 `A` 一个 `B` 循环，后半部分一个 `A` $k$ 个 `B` 循环，二分求出这个分界线。

##### AGC020E Encoding Subsets

记 $f(S)$ 表示状态 $S$ 的答案，直接记搜。可证状态数很少，是 $O(N^3+2^{N/8})$ 的，因此能过。

##### AGC020F Arcs on a Circle

考虑每个线段放置的位置的小数部分，只有小数部分的相对顺序会影响答案，因此如果把每个长度为 $1$ 的线段拆成 $n$ 份来表示相对位置，每种位置只会被占一次。同时状压每种线段和每种位置即可。

##### AGC021E Ball Eat Chameleons

枚举 $R$ 和 $B$，首先 $R<B$ 无解，$R\ge B$ 时还需满足能从序列中找出 $N-(R-B)$ 个子序列 `RB`。如果画到平面上，就相当于不经过斜线 $y-x\ge R-N+1$ 的路径计数，这是卡特兰数经典题。需要注意特判 $R=B$ 时必须以 `B` 结尾。

##### AGC021F Trinity

先不考虑空行，假设 $f(i,j)$ 表示行都非空的 $i$ 行 $j$ 列方案数，那么总答案是 $\sum \binom{n}{i} f(i,m)$。

考虑按列 dp，新增一列时枚举有 $k$ 行被新增了，即 $f(i,j) \to f(i+k,j+1)$，当 $k=0$ 时系数显然是 $\binom{i}{0}+\binom{i}{1}+\binom{i}{2}$，否则列最值一定在新增行的上下方。可以把列最值也看成空行，那么系数就是 $\binom{i+k+2}{k+2}$。转移形式是卷积，FFT 优化即可。

##### AGC022D Shopping

首先所有 $t \bmod 2L$，考虑朴素做法，就是从左到右每到一个点就额外花 $2L$ 的时间让车跑一圈。考虑两个点 $A<B$ 满足 $A$ 左边的路程 $\ge t_A$，$B$ 右边的路程 $\ge t_B$，那么先处理 $B$ 再处理 $A$ 就可以减少 $2L$ 的时间。因此求出最多的这种配对数即可。注意特判最后一个点是否需要跑一圈。

##### AGC022E Median Replace

在最后放一个 $1$，然后设序列 $a$ 是每两个 $1$ 之间的 $0$ 个数。可以发现操作在 $a$ 上相当于一个 $>2$ 的数 $-2$，或者将相邻两个 $x,y$ 合并成 $x+y-1$，或者将相邻两个 $0$ 消掉。因此奇数可以不管，剩下的偶数要找出两个 $0$ 使得前后的数的个数都是偶数个。于是就可以 dp 了。

##### AGC022F Checkers

$X$ 很大，不管它，把数都看成 $n$ 维向量。其次，向量里的顺序不影响，这里考虑向量里的数构成的多重集。即一开始所有都是 $\{1\}$，每次操作选 $A$ 和 $B$，合并为 $2A\cup -B$。

观察发现，合法集合里有 $\pm 2^k$ 就有 $\pm 2^{k-1}$，且总和一定为 $1$。此外，还有一个条件，即对于每个 $i$ 可以调整 $\pm 2^i$ 的符号来使得 $\le i$ 次项和为 $1$。证明必要性显然，考虑用归纳法证充分性，即合法集合 $S$ 定能拆成合法集合 $2A$ 和 $-B$。显然 $A$ 和 $B$ 其中一个符合这个条件时另一个一定符合。

不妨设 $-1\in S$，记 $S$ 的最小正值为 $+2^k$，假如更小的负次项都至少出现两次，那么构造 $A=\{-1,-2,\ldots,-2^{k-2},+2^{k-1}\}$ 合法。假如 $-2^1$ 只出现一次，取 $B=\{1\}$ 合法。否则 $S$ 本身就不合法。

最后考虑怎么 dp，设 $f(i,j)$ 表示 $i$ 个数，当前和是 $1+j\times 2^m$ 的形式的答案，其中 $2^m$ 是当前最高次项。dp 下一次项时并不需要知道 $m$ 具体是多少，只用枚举下一次项的正负个数即可。

##### AGC023D Go Home

考虑两端点的人数分别是 $A,B$，当 $A\ge B$ 因为 $B$ 打不过 $A$ 所以不能在 $A$ 之前到家，所以 $B$ 在 $A$ 到家之前会希望 $A$ 赶紧到家，因此可以看作 $A$ 处理。$A<B$ 同理。递归直到 $S$ 只有一侧有人即可。

##### AGC023E Inversions

考虑 $A_i\le A_j$ 位置处的贡献，显然是把 $A_j$ 修改为 $A_i$ 后的可能排列数除 $2$。考虑如何统计排列数，设 $c_i$ 是 $\ge i$ 的 $A$ 的个数减 $(N-i)$，那么答案是 $\prod c_i$。如果把 $A_j$ 改为 $A_i$ 相当于 $A_i+1\sim A_j$ 这段的 $c$ 减 $1$。设 $d$ 是 $\frac{c_i-1}{c_i}$ 的前缀积，那么新答案就是原答案乘 $\frac{d[A_j]}{d[A_i]}$。问题变为求 $j$ 前面小于 $A_j$ 的 $\frac{1}{d[A_i]}$ 的和，可以 BIT。注意 $d$ 是 $0$ 的情况，记一下 $0$ 个数就行。

对于 $A_i>A_j$ 的位置类似的求正序对然后用总的减就行了。

##### AGC023F 01 on Tree

给每个节点设置一个权值 $R_i$ 是节点上 $0$ 的个数除以 $1$ 的个数，每次把 $R$ 最大的点往尽可能前放一定不劣，因此当前树上 $R$ 最大的点一定在其父节点之后，将其与父节点合并然后继续下一轮。

##### AGC024D Isomorphism Freak

显然颜色数是 $\lfloor\frac{D+1}{2}\rfloor$。固定直径的中心以后叶子数显然是每个深度的最多儿子数之积。直径为奇数个点时要额外考虑中心和一个相邻点共同作为中心的情况。

##### AGC024E Sequence Growing Hard

考虑插入一个数 $A$ 的时候它后面的数 $B$，如果 $A<B$ 就挂了，$A=B$ 可以看作是在 $B$ 后面插入，$A>B$ 就合法。因此每个数插入的时候向后面连边就形成一个森林，满足儿子比父亲权值和标号都大。树形 DP 即可。

##### AGC024F Simple Subsequence Problem

考虑直接 dp 出每种串的出现次数。一个一个字符匹配，设 $f(A|B)$ 表示串是 $A+\mathrm{subseq}(B)$ 的形式的答案，考虑向后转移一个字符，要么取 $B$ 中第一位，要么取另一种字符在 $B$ 中第一次出现。

##### AGC025D Choosing Points

显然格点上不存在长为奇数的环使得边长都是 $\sqrt{D}$，因此每个限制是个二分图，每次都取较大的一半就行了。

##### AGC025E Walking on a Tree

答案可以取到上界，考虑递归构造，删除一个叶子的时候，如果有两条路径都到这个叶子，合并这两条就行了。

##### AGC025F Addition and Andition

观察发现 $\&$ 起来的 $1$ 会逐渐往高位移，但显然不会追上前一个 $1$。因此从高到低考虑 $k$ 次之后的答案，如果当前是 $11$ 就往前走，遇到 $10,01$ 就暴力，遇到 $00$ 可以一段跳过，因为低位不影响高位所以遇不到下一个 $11$。

考虑复杂度，当前进位是 $11$ 的时候总的 $1$ 个数必然减少 $1$，并且变为 $10,01$，而进位是 $10,01$ 的时候要么 $1$ 的个数减少 $1$，要么变成 $11$，因此每两步总的 $1$ 个数至少减少 $1$，均摊就是 $O(N)$ 的。

##### AGC026D Histogram Coloring

考虑由上一行推到下一行，显然可以直接反色。如果上一行交替排列，这一行也可以和上一行相同。因此在笛卡尔树上 dp 就行了。

##### AGC026E Synchronized Subsequence

考虑一个 `ab` 个数相同的极短段，如果 `a` 在前，那么可以最大从中选出形如 `abab...ab` 的串。如果 `b` 在前，那么最大一定是从中选出一组后缀，因为选了第 $i$ 个 `b` 再选第 $i+1$ 个 `b` 一定更优。显然每段要么不选要么选最大，直接 dp 即可。

##### AGC026F Manju Game

黑白染色，假设第一个是黑色。如果 $n$ 是偶数显然答案分别是 $\max(B,W)$ 和 $\min(B,W)$。

如果 $n$ 是奇数，考虑先手怎么操作，可以选一个白的，然后后手选一边拿完，变成一个子问题；先手也可以选边上的黑色直接结束游戏。也就是说先手保底有 $W$ 收益，可能会在某一次子问题的时候选黑以额外增加收益。

对于一种用白色把序列划分的方法，显然后手可以递归到 $B'-W'$ 最小的一段去，因此先手的收益就是 $W+B'-W'$。因此问题变成找一种划分使得每段 $B'-W’$ 的最小值最大。可以二分答案然后贪心判断。

##### AGC027D Modulo Matrix

黑白染色，设黑格子是周围白格子的 $lcm+1$，只需要保证互不相同。按斜行分配奇质数即可。

##### AGC027E ABBreviate

设 `a` 为 $1$，`b` 为 $2$，那么 $S$ 可以变成字符 $c$ 当且仅当 $S=c$，或者 $\mathrm{Sum}(S) \mod3 =c$ 且 $S$ 有至少两个相邻字符相同。考虑 $S$ 变成 $T$ 的过程相当于对 $S$ 做一个划分，因此 dp 即可。

##### AGC027F Grafting

考虑如果有一个点没动过，那么可以求出哪些点不需要也不应该动。对于要动的点，$A$ 中满足儿子比父亲先动，$B$ 中满足父亲比儿子先动，这个关系不成环就行了。

但是有所有点都动的情况，如 1-2-3-4-5 变成 3-1-2-4-5，因此可以枚举第一步怎么动，第一步之后这个点就不会再动了。

##### AGC028C Min Cost Cycle

考虑总的减去被删的，假设被删的状态是 $00,01,10,11$，显然 $00$ 和 $11$ 个数相同，假设 $z$ 个。现需要找出一个顺序使得相接的地方的恰有 $1$ 个 $1$。显然 $z=0$ 的时候不能同时有 $01$ 和 $10$，这个特判。有 $00$ 的时候能构造出来：把 $z$ 个 $11$ 和 $z-1$ 个 $00$ 串一起，然后左边全放 $10$，右边 $01$，最后用个 $00$ 串起来。因此贪心即可。

##### AGC028D Chords

设 $f(l,r)$ 表示存在 $l$ 到 $r$ 这个连通块的方案数，直接容斥用总的减去可能存在一个 $f(l,k)$ 的方案数即可。

##### AGC028E High Elements

一个一个加，考虑判断当前状态是否可行。假设两个数列最大值分别是 $max_0, max_1$，好点个数是 $cnt_0,cnt_1$。

如果说原序列的好点叫真好点，显然我们可以让某个序列新增的好点只有真好点，因为如果都有假好点，交换这一对就行了。这样假设 $a$ 新增好点的只有真好点，如果 $b$ 新增了 $k$ 个真好点，$m$ 个假好点，而剩余的真好点有 $q$ 个，有 $cnt_0+q-k=cnt_1+k+m$，移项发现是要求 $2k+m$ 是定值，即后缀找出一个上升子序列，其中好点贡献是 $2$，非好点贡献是 $1$，要求贡献恰好为 $c$。显然 $c$ 能凑那么 $c-2$ 肯定能凑，因此分奇偶记后缀的最大权上升子序列就行了，BIT。

##### AGC028F Reachable Cells

大致思路是分治，考虑上面走到下面的方案数，枚举上面的格子，看它能走到分界面的哪些位置，想办法维护这些位置能到的下面的格子的并。

细节过多，详细题解移步[王修涵博客](https://blog.csdn.net/wxh010910/article/details/83065702#t5)。

##### AGC029C Lexicographic constraints

二分答案，维护串，变长就加 $0$，没变长就对应位加 $1$，拿个栈模拟就行了。

##### AGC029E Wandering TKHS

考虑一个点比父节点多走多少，假设 $1$ 到父节点和 $1$ 到父节点的父节点最大值分别是 $max$ 和 $max'$，那多走的大概是个 $Reach(u,max)+1$ 或者 $Reach(u,max)-Reach(u,max')$ 的形式。算一下可以发现一个点只会在他到 $1$ 的链上最大值处被 $Reach$ 算到，因此 $Reach$ 直接暴力实现复杂度就均摊了。

##### AGC029F Construction of a tree

假设 $1$ 是根，先网络流从每个集合里选一个数形成一个 $2\sim n$ 的排列，把它们看作每个集合那条边的子节点。接下来从 $\{1\}$ 开始贪心能找到父节点就接上去。显然能构造出来一定是对的，考虑中途一步不能构造出来的时候，说明无论如何与已经确定的 $k$ 个点相关的边数都达不到 $k$ 条，显然这在树中是不可能的，因此是无解的。

##### AGC030C Coloring Torus

考虑朴素染色，对 $(i,j)$ 染 $(i+j)\bmod n$。当 $n$ 是偶数的时候，每个 $t$ 恰与一个奇行 $t\pm 1$ 和一个偶行 $t \pm 1$ 相邻，那么把奇偶行的 $t$ 替换成两个不同的颜色 $t_1,t_2$ 是不影响合法性的。因此对一个偶数 $n$，能构造出 $k\in [n,2n]$ 的答案。

##### AGC030D Inversion Sum

$f(i,j)$ 表示 $a_i>a_j$ 的概率，dp 即可。

##### AGC030E Less than 3

先差分，变为 $1$ 移动，因为限制显然不会出现两个 $1$ 在中间抵消或出现的情况，但可以在开头抵消或是移到末尾处理掉。而且显然任意一种局面都有方案移动到另一种局面，因此枚举两个串的 $1$ 怎么对应就行了。

##### AGC030F Permutation and Minimum

把有值的数对 $(x,y)$ 全删掉，再把 $(-1,-1)$ 看作无序的，最后乘阶乘。考虑从大往小填，有两类数，A 类是出现过的，B 类是没出现过的，显然不能出现 $(A,A')$ 这样的数对，因此考虑 dp，设 $f(x,i,j)$ 表示当前填到 $x$，$(B,-1)$ 有 $i$ 对，$(A,-1)$ 有 $j$ 对的方案数即可。注意 $B$ 填入 $(A,-1)$ 的时候因为 $A$ 有序所以要乘 $j$。

##### AGC031D A Sequence of Permutations

用 $(A,B)$ 表示置换的叠加 $ABA^{-1}$，找规律发现 $(T,A)$ 和 $(T,B)$ 在 $6$ 次之后会变成 $(TB^{-1}ABA^{-1},A)$ 和相应的 $B$，因此只需要求 $(B^{-1}ABA^{-1})^{\frac{k}{6}}$ 即可。

##### AGC031E Snuke the Phantom Thief

枚举一共恰好选了 $K$ 个，限制形如 $\le x$ 的至多 $i$ 个，就能转成排序后从第 $i +1$ 个开始坐标必须 $>x$。两维各有限制，费用流做类似匹配即可。

##### AGC031F Walk on Graph

倒过来，问题变为 $x\to 2x+c$。因为模数是奇数，$x \leftrightarrow 2x+c$。因为当有两条边 $a,b$ 相邻时，同一点上 $x=4x+3a=4x+3b$，因此模数可以变成 $\gcd(MOD,3(a-b))$，假设是 $3g$。

假设边模 $g$ 都是 $z$，显然问题 $+z$ 而边 $-z$ 是不影响答案的。因此可以让边都是 $g$ 倍数。

假设固定状态 $[1,x]$，那么其余状态是 $[u,2^{p}x+qg]$ 的形式，$q<3$。因为 $x=4x+3c$，而 $3c$ 含 $3g$ 因此模掉了，所以 $x$ 和 $4x$ 也等价，所以 $p<2$。所以状态 $6n$ 个，并查集连一连，最后询问看看能否找到 $p,q$ 是 $4$ 的次幂即可。

##### AGC032C Three Circuits

首先图是个欧拉图，有度数 $\ge 6$ 的点有解，有三个度数 $=4$ 的点有解，有两个度数 $=4$ 的点时，只有这两个点各有一自环才有解。

##### AGC032D Rotation Sort

操作相当于把数扔到往左往右任意一个位置，因此选出不动的数以后剩下的数的方向是固定的，从小到大 dp 不动的数即可。

##### AGC032E Modulo Pairing

可以用调整法证明：存在一个分界点，前面是 $x+y<M$ 的匹配，后面是 $x+y\ge M$ 的匹配，且两边的匹配一定是第一个匹配最后一个，第二个匹配倒数第二个，以此类推。二分这个分界点即可。

##### AGC032F One Third

把所有点写成 $k\times \frac{1}{3}+\omega$ 的形式，并且把 $k$ 相同的称为同色的，这样问题变为 $[0,\frac{1}{3})$ 内有 $n$ 个点，求期望最近异色点对距离。

有结论为长度为 $1$ 的线段切成 $n$ 段，第 $k$ 短的线段期望长度是 $\frac{1}{n^2}+\frac{1}{n(n-1)}+\cdots +\frac{1}{n(n-k+1)}$，因此枚举第 $i$ 长的段是最长不同色段，答案还要乘上前 $i-1$ 段都不同色的概率 $3^{i-1}$。

##### AGC033D Complexity

显然答案 $\log$ 级别，记 $f(t,k,l,r)$ 表示答案是 $t$ 时第 $k$ 行第 $l$ 至 $r$ 列至多延伸到第几行，列同理，转移 $O(1)$。

##### AGC033E Go around a Circle

假设开头是 R，那弧上必不能有 B 相邻。若串全是 R 就没有别的限制。若串有 B，那么弧上不能有偶数长度的 R，不然会被开头的奇偶性卡死，且长度不能超过这个长度 $+1$。而如果串后面存在两个 B 中间有奇数个 R，那么弧上连续的 R 长度也不能超过这个长度，不然跑不过去。有这三个条件 dp 即可。

##### AGC033F Adding Edges

考虑如果最终 $G$ 中有三元环 $a,b,c$，且 $T$ 中存在路径 $a,b,c$ 是一条链，那么 $G$ 中可以不要 $(a,c)$ 这条边。删边以后最终答案 $(x,y)$ 存在当且仅当存在 $T$ 中的路径 $x,a_1,a_2,\ldots,a_k,y$，且这个序列相邻两个在新 $G$ 中有边。

考虑怎么维护新 $G$，一条一条加边，如果某个时刻存在 $(a,b)(a,c)$ 且树上路径是 $a,b,c$，就把 $(a,c)$ 删掉换成 $(b,c)$。记 $top(a,b)=c$ 表示以 $a$ 为根时，存在边 $(a,c)$ 且 $c$ 是 $b$ 的祖先。加入 $(a,b)$ 时如果存在 $top(a,b)$ 就改为加入 $(top(a,b),b)$，否则可以加入 $(a,b)$，然后看看 $b$ 子树里是否存在 $(a,c)$ 需要被代替。最后 dfs 算下答案。

##### AGC034D Manhattan Max Matching

绝对值化开有四种结果，建四个虚点表示 $(\pm x,\pm y)$ 这四种符号然后跑费用流即可。

##### AGC034E Complete Compress

枚举集合点，那么合法时一定有方案使所有点都是向上移的。剩余部分和“榕树之心”类似，每个点都让深度和最大的去跟其他儿子消，如果太大了则有可能消不完，递归到儿子里去消即可。

##### AGC034F RNG and XOR

问题反过来就是一个数变成 $0$ 的次数，因此有 $E_0=0$，$E_x=\sum_{y}E_{x\oplus y}p_y+1$。那么 $E$ 和 $p$ 的异或卷积 $E\oplus P$ 就是 $E-I+2^n$，其中 $E_0$ 处多一个 $2^n$ 是因为 $P$ 和为 $1$ 因此 $E$ 卷积后和不变。即 $E\oplus(P-1)=-I+2^n$，可以求解出一个伪解 $E'$。求出的 $E_0$ 可能不为 $0$，注意到 $tI\oplus(P-1)=0$，因此 $E'-E'_0I$ 即为答案。

##### AGC035C Skolem XOR Tree

显然 $N$ 是 $2$ 的次幂 $N$ 就配对不上了。否则先连 $(1,2,3,1,2,3)$，然后连 $(1,2x,2x+1)$ 和 $(1,2x+1,2x)$ 就能把 $2x$ 和 $2x+1$ 配对上了。$N$ 是偶数就在 $1$ 的邻接点上找两个去连 $N$ 就行了。

##### AGC035D Add and Remove

考虑逆推，设 $f(l,r,x_l,x_r)$ 表示区间 $(l,r)$ 缩完且左右端点贡献分别是 $x_l$ 和 $x_r$ 倍的答案，中间转移的贡献就是 $x_l+x_r$ 倍。可以发现状态数是 $Cat_{16}$ 的，因此直接爆搜。

##### AGC035E Develop

考虑被删的数，如果 $x$ 向 $x-2$ 和 $x+k$ 连边，那么被删集合合法当且仅当无环。$k$ 是偶数奇偶独立，随便 dp 一下。$k$ 是奇数的时候显然有环一定是选了形如奇数区间 $[l,r]$ 和偶数区间 $[r-k,l+k]$。把偶数区间 shift 一下就是奇数区间 $[l,r]$ 和偶数区间 $[r,l+2k]$，即偶数的 $l+2k$ 不能存在一条到奇数 $l$ 的全选的链，也 dp 一下就行了。

##### AGC035F Two Histograms

考虑如果存在 $k_i+1=j,l_j=i$，即一个反 L 形，那么可以让 $k_i+1$，$l_j-1$。显然这样规范化后的序列唯一对于可能的局面。因此直接容斥，枚举有多少对反 L 形即可。

##### AGC036D Negative Cycle

没有负环因此考虑跑最短路后的 $dis$ 数组，显然有 $dis_i\ge dis_j$，$dis_j\le dis_i+e(i,j)$。再考虑差分，设 $q_i=dis_i-dis_{i+1}$，所以 $q$ 都是非负的，而限制变为了 $q_i+q_{i+1}+\ldots+q_{j-1}\le1$ 或 $\ge 1$。图合法只需要 $q$ 合法，而且 $q$ 取 $\ge 2$ 的数无益，因此考虑 $q\in\{0,1\}$。设 $f(i,j)$ 表示上两个 $1$ 在 $i,j$ 位置的答案，从前往后 dp。

##### AGC036E ABC String

把连续相同的缩起来，假设 A 最少，B 其次，C 最多。首先考虑把 C 弄得和 B 一样多，按 A 将串分段后，设 $x$ 是含 B 的段数，$y$ 是不在头尾且只有一个 C 的段数。显然 $x\ge y$ 时是可以通过把 $x$ 型两头的 C 去掉来使得 B 和 C 一样多的，考虑 $x < y$ 的时候，就只能删 A 了，而可以发现删去一个 $y$ 型旁边的 A 可以使 $y-1$ 而 $x$ 不变。因此先删 A，删到 $x\ge y$ 为止，然后删 C，删到 B 和 C 一样多为止，最后显然一定可以通过删连续的 BC 或者 CB 来使得三者一样多。

##### AGC036F Square Constraints

考虑容斥，枚举有 $k$ 个是下界以下的。后 $N$ 个数没有下界，设前 $N$ 个数下界是 $a_i$，上界是 $b_i$，后 $N$ 个数上界是 $c_i$，可以发现，$b$ 是比 $a$ 和 $c$ 全都大的。现在就是要选一些界出来作为当前的限制，如果确定了限制，那么方案数很好算，是限制排序后 $\prod(limit_i-i)$。考虑将 $a,b$ 全部排序以后从小到大 dp，$f(i,j)$ 表示前 $i$ 个限制有 $j$ 个没选的答案（只有 $a$ 类能不选），下一个 $a$ 类如果不选而是用 $c$ 类的话，因为钦点了 $a$ 类总个数是 $k$，所以就能算后面 $c$ 类的贡献是 $limit-(n+k+j)$ 了。

##### AGC037D Sorting a Grid

一个数第二步前和第二步后所在的行是确定的。考虑逐列确定第二步前后的状态，就是操作前和操作后的行号要一一对应，就是一个匹配，于是逐列网络流。显然可证一定有最大匹配。

##### AGC037E Reversing and Concatenating

假设第一次 $U$ 里最小字符 c 最长有连续 $l$ 个，那么把这 $l$ 个放最后每次翻倍，最后一次放最前面，就能在最前面弄出 $2^{k-1}l$ 个 c。如果 $2^{k-1}l$ 不足 $n$，就要后面部分也尽可能小，可以发现这后面部分一定是连续 $l$ 个 c 的前面反转，取最小即可。

##### AGC037F Counting of Subarrays

考虑对于一个序列如何判定，找到一个最小值 $m$ 的极长连续段 $[l,r]$，那么如果 $r-l+1<L$，显然这个 $m$ 就在中间卡住了，就不是好的。否则把这些 $m$ 给等价替换了，相当于 $(r-l+1)/L$ 个 $m+1$，然后继续判定。这东西的复杂度使用一个链表和堆实现，显然就是 $O(n\log n)$ 的。

考虑怎么计数，给每个数一个真实左右贡献倍数 $L_i$ 和 $R_i$，一个合法的区间 $[i,j]$ 就贡献 $L_iR_j$。按上面的方法合并一些 $m$ 的时候，就可以把这些 $m$ 内部的个数算出来，然后合并成 $m+1$，小心处理贡献的倍数。最后合并后需要将这些 $m+1$ 内部的个数减掉，避免之后再次合并的时候算重。

##### AGC038E Gachapon

min-max 容斥，然后考虑到 $\mathbb{E}(\min\{S\})$ 就是 $\sum_i$ [$i$ 次内没有东西达到 $B$ 的概率]，因此 dp 后面这个即可。

##### AGC038F Two Permutations

显然一个环只能两种状态选一。假设 $i$ 在 $p$ 所在环为 $a$，在 $q$ 所在环为 $b$，那么 $a$ 和 $b$ 的状态决定了代价，用最小割模型去搞就行了。

##### AGC039D Incenters

设 $AI,BI,CI$ 延长交圆于 $A',B',C'$，那么这三点都平分对应的弧。算弧度可得三线交点 $I$ 是 $A'B'C'$ 的垂心。又因为欧拉线上，$|OH|=3|OG|$，而 $O=(0,0),G=\frac{1}{3}(A'+B'+C')$，因此 $I=A'+B'+C'$。枚举 $B,C$ 算弧 $B,C$ 的中点 $A'$ 的贡献即可。

##### AGC039E Pairing Points

直接 dp，设 $f(l,r,p)$ 表示区间 $[l,r]$ 想连起来，$p$ 和区间 $[l,r]$ 外已经连了的方案数，再设 $g(a,b,c,d)$ 表示区间 $[a,b]$ 和区间 $[c,d]$ 连起来且只有一条跨区间边的方案数，随便 dp 一下，答案就是 $f(2,n,p)$ 的和。

##### AGC039F Min Product Sum

先把问题转化一下，问题相当于说有两个矩阵 $A$ 和 $B$，$A$ 的行全比 $B$ 小，$A$ 的列全比 $B$ 小。如果钦点了 $A$ 的行最大值和 $B$ 的列最小值，那么每个格子就有些候选值，并且两个矩阵的右上一部分是每行/每列必须要有一个卡着极值的。

考虑把矩阵划开成有没有极值要卡的那条折线，沿着折线走，发现向下走的时候 $A$ 的右边和 $B$ 的左边的方案数是很好算的，向右走的时候 $A$ 的上边和 $B$ 的下边的方案数是很好算的，因此 dp 这根折线就行了。

##### ARC089F ColoringBalls

考虑把最终结果划成有色的段，并把连续的 R 和 B 缩一起。对于有 $t-1$ 个 B 的段，称它属于第 $t$ 组，则第 $t$ 组的长度至少是 $2t-3$（$t=1$ 例外）。考虑一个 $t\ge 2$ 的组，它的染色方法必须 `rb` 开头，且长度为至少为 $t$。

考虑对 $N$ 整数划分来枚举每一段是第几组，这至多只有 $418662$ 种情况。一种枚举下显然可以贪心分配判断是否合法，如果合法，考虑贡献，首先有一个段与段之间的阶乘除阶乘，然后隔板法分组，考虑可以为空的只能是 $t\ge 2$ 的组的两边的 R，或者最开始和最结尾的 W。贡献是 $N+1+\sum_{v\ge 2}2$ 里选 $\sum 2v$。

##### ARC091F Strange Nim

打表找出递归式，如果 $n$ 是 $k$ 的倍数，$\mathrm{sg}(n,k)$ 就是 $n/k$，否则是 $\mathrm{sg}(n-n/k-1,k)$。算的时候后一种一段一起处理即可。

##### ARC092F Two Faced Edges

对于边 $(a,b)$，如果 $b$ 能到 $a$ 那么 SCC 个数不变当且仅当删去 $(a,b)$ 后 $a$ 能到 $b$，如果 $b$ 不能到 $a$ 则相反。$b$ 能不能到 $a$ 显然易求，而求删去 $(a,b)$ 后 $a$ 能不能到 $b$ 可以分别考虑 $a$ 的出边中走这条边之前的边和之后的边能不能到 $b$，因此正反各扫一遍出边 dfs 即可。

##### ARC093E Bichrome Spanning Tree

考虑求一棵生成树，假设缺的权值是 $t$，如果需要用边去替换，假设替换权值是 $t$ 的有 $a$ 个，多于 $t$ 的有 $b$，方案数是 $2\times (2^a-1)\times 2^b$。如果 $t$ 是 $0$，那么也可以给当前染成黑白两色，就是 $(2^{n-1}-2)2^{m-n+1}$。

##### ARC093F Dark Horse

显然就是要求 $n$ 个集合的 $\min$ 不能 $\in A$。考虑容斥，变为求硬点了一些集合的 $\min \in A$ 的方案数，显然可以 dp，从大到小考虑 $A_i$，设 $f(S)$ 表示选了 $S$ 这些集合被填了且 $\min \in A$ 的方案数即可。

##### ARC095F Permutation Tree

显然图是一条链挂上若干叶子，而且链是直径时最优。构造最小显然每次放最后或者倒数第二个就行。两个方向各做一次取 $\min$ 就行了。

##### ARC096E Everything on It

容斥，求有至少 $i$ 个被选 $\le 1$ 次的概率，发现需要求一个把这 $i$ 个划分成 $j$ 组的方案数，特别的是每个数可以不存在于任何一组。没有限制的地方再算下贡献就行了。

##### ARC096F Sweet Alchemy

首先差分，就变成了多重背包，价值和体积是子树和。体积和个数比较大，不能常规做。然而价值较小，考虑按性价比从大到小排序，贪心显然是错的。对于最优解如果出现一种情况是对于 $p<q$，$p$ 剩下了 $v_q$ 个，$q$ 选了 $v_p$ 个，那么把这些 $q$ 换成 $p$，体积变小肯定不劣。因此最优解一定有种方案只有一个地方选了 $[N,limit_i-N]$ 个，前面剩下少于 $N$ 个，后面选了少于 $N$ 个。就相当于说如果去掉前面剩下的那部分 $N$，后面选的那部分 $N$，剩下的部分一定是前面全选，后面不选，就是一个正确的贪心了。为了算去掉这部分可以设每个东西个数都是 $N$，然后多重背包，对剩下的东西贪心选即可。

##### ARC097F Monochrome Cat

黑色叶子删掉，考虑最终方案如果必须回到起点，可以求出一个答案。但实际上最优方案一定会节省最后白叶子到白叶子的路径，并且路径上某些点会因此减少 $2$ 的贡献。算出每个点少走一次会减少的贡献，跑个直径即可。

##### ARC098F Donation

显然可以把题目要求变成时刻钱数需时刻 $\ge c_i = \max(a_i-b_i,0)$，因为捐了再走一次不优。找到 $c_i$ 最大的 $i$，那么可以发现子连通块就是子问题，然后在 $i$ 决策一下怎么走。所以按 $c$ 的大小重新建树然后 dp 即可。

##### ARC099F Eating Symbols Hard

考虑把最终结果写成生成函数 $\sum a_ix^i$，位置不好维护，考虑在前面加字符，那么 $f(\texttt{+/-}S)=f(S)\pm 1$，$f(\texttt{>/<} S)= f(S)x^{\pm1}$。而这四种都是线性变换，因此 $\texttt{+-><}$ 互为逆运算。一个区间 $f(S[l;r])$ 可以写成考虑成对 $f(S[1;r])$ 执行 $S[1;l-1]$ 的逆变换。预处理出前缀的 $f$ 和逆变换的形式，map 存一下算就行了。

##### ARC100F Colorful Sequences

考虑计算不符合要求的总个数，如果 $A$ 全不相同，直接求出所有不合法的序列中包含的长为 $M$ 的全不同段的总个数，再乘个概率就行。如果 $A$ 有相同，那么左右独立，分别 dp 出来合并即可。

##### ARC101E Ribbons on Tree

考虑容斥，假设钦点了 $k$ 条边不能覆盖，那就是 $(-1)^k$ 乘上每块内随意匹配的方案数。可以 dp 这个东西，设 $f(i,j)$ 表示 $i$ 点有 $j$ 个点向上匹配的贡献，除了背包外再加一种钦点这条边不选，内部把它匹配掉的方案数乘上 $-1$ 即可。

##### ARC101F Robots and Exits

显然方案数只与一个球离左右的距离有关，而且只与距离的相对大小有关。考虑一个暴力的 dp，按离左边的距离排序，设 $f(i,j)$ 表示考虑前 $i$ 个，当前往右边走的最大值是 $j$ 的方案数，转移下一个的时候要么还是继续往左走，要么使得下一个球是往右掉下去的。因为必须往右走的时候才往右走，这样显然合法的方案一定是只会被算一次的。这个 dp 用树状数组即可。

##### ARC102F Revenge of BBuBBBlesort!

显然操作了 $i$ 以后那么 $i-1,i,i+1$ 都没法再操作了，因此一个数只能单向移动。所以不动点不能移动。考虑把序列中的相邻同类型点划开划成交替的段，那么只能段内移动。而因为只能单向移动，所以同一段内要向左的动点必须递增，向右也是。可以发现，满足上述条件一定能排好序，只需要每次选择向右的动点、不动点、向左的动点即可。

##### ARC103D Robot Arms

首先 $x+y$ 奇偶性需相同。观察发现当两点曼哈顿距离 $\le 2k$ 时，加入一条长为 $k$ 的线段一定可以使这两点的曼哈顿距离 $\le k$。因此构造 $D$ 是 $2^{30},\ldots,4,2,1$ 即可让目标点与当前点的曼哈顿距离不断折半直到相遇。注意若 $x+y$ 是偶数则还需补一个 $1$。

##### ARC103F Distance Sums

按 $D$ 从小到大排序，倒着处理，确定 $v$ 的父亲。假设当前 $v$ 的子树大小是 $size$，那么显然它的父亲的 $D$ 应当是 $D_v+2size-n$，且因为 $D$ 互不相同，它父亲的 $D$ 一定比它小，不然不合法。依次确定即可。注意最后判 $D_1$ 是否正确。

##### CF506C Mr. Kitayuta vs. Bamboos

考虑二分答案，倒过来做，问题变成一开始所以竹子高度 $mid$，每次所有竹子都会变矮，可以增加一些竹子的高度，中途不能 $<0$，并且最后需 $\ge h_i$。因此贪心，每次选最快将要变成负的增加即可。

##### CF506E Mr. Kitayuta's Gift

首先写个 dp，可以发现是个自动机的样子，并且有些点有 $24$ 或者 $25$ 个自环。一条有 $k$ 个 $24$ 点的路径的 $25$ 点的个数是确定的，并且路径方案数只和点数有关，所以可以先 dp 出来有 $k$ 个 $24$ 点的路径条数。dp 出来以后可以把这些路径压缩成一个 $O(n)$ 个点的自动机，这样就能矩阵快速幂了。注意总长度为奇数的时候最后一步不能同时匹配两个字符，需把这种情况减掉。

##### CF512D Fox And Travelling

显然可删的部分要么是有根树要么是无根树，有根树好 dp，无根树可以枚举根是哪个 dp，留下 $i$ 个点的方案恰好被算了 $i$ 次，除 $i$ 就行了。

##### CF516D Drazil and Morning Exercise

每个点的 $d$ 很好求，考虑如果以直径中点为根，那么越深的点 $d$ 越大。因此若从大到小做双指针，维护连通块的时候删点就一定删的是叶子，不影响连通性。所以并查集就行了。

##### CF521D Shop

首先赋值最多做最大的那次，可以变成加。而加放在乘之前不会变劣，并且从大到小加不会变劣。这样排了以后每次加前和加后的值就已经确定，可以等效换为乘。都换为乘后从大到小排序就行了。

##### CF526F Pudding Monsters

可以线段树。但是贴个析合树板子上去就完事了。

##### CF528C Data Center Drama

考虑先加边，使得度数都为偶数，然后如果边不为偶数就加个自环。求一条欧拉回路，交替地给回路上的边定正反向即可。

##### CF538G Berserk Robot

先转切比雪夫，这样两维就独立了。再判下奇偶性。一维上可以按 $t_i\bmod L$ 排序，这样相邻两个之间差的是若干个整段加上 $(t_i\bmod L,t_{i+1}\bmod L]$ 这个零散段。可以设整段的贡献是 $x$，那么根据相邻两个之间的距离差和零散段怎么贡献，可以列出关于 $x$ 的不等式，解就行了。解出一个合法解再扫一遍就好构造了。

##### CF547D Mike and Fish

直接同一行的两两连边，同一列的两两连边，显然是个二分图，二染色即可。

##### CF547E Mike and Friends

问题拆成两个前缀，建后缀数组，就变成了找到 lcp 足够大的一段区间，询问这里面有多少是前 $i$ 个串的。离线从前往后加即可。

##### CF555E Case of Computer Network

边双里的可以定向使得互相连通，剩下的图就变成了一个森林。给树上一条路径定向树上差分即可。

##### CF559E Gerald and Path

设 $f(k)$ 表示 $k$ 左侧的点交 $(-\infty,k]$ 内的最大答案，dp 时枚举剩下区间的最右端点是谁贡献的，则区间内的其它灯都会朝左，一直向左扩展。预处理每个点能到的最左端点即可做到 $O(n^2)$。

##### CF566C Logistical Questions

显然这个带权重心只有一个且越向外侧权值越大，所以可以点分求解。解决从一个点分中心是否要往一个子树走的时候直接求值不便，可以考虑求导。

##### CF568C New Language

枚举一下前缀，后面整个 2-sat 就行了。

##### CF568E Longest Increasing Subsequence

考虑典型的求 LIS 方法，设 $len_i$ 和 $from_i$ 表示 $i$ 位置结尾的 LIS 长度和上一个位置，dp 过程中再记 $f_j$ 和 $last_j$ 表示当前长度为 $j$ 的 LIS 末尾最小值和所在位置。当出现一个非空位的时候直接二分 $f$ 更新，出现空位的时候需要倒着枚举集合，用双指针替代二分去 $\log$。由此复原序列就较为简单。

##### CF571D Campus

考虑先处理第二个并查集，可以启发式合并，求出询问的点最后一次归零是啥时候。这样如果没有归零操作，只用维护第一个并查集，答案就是这时候的点权减去清零时的点权。维护点权也启发式合并即可。

##### CF573E Bear and Bowling

写个 dp 发现每次转移都是一个后缀，差分一下就是一个典型的平衡树维护凸壳。

##### CF575A Fibonotci

一看就是矩阵快速幂，特殊值的地方单独算，特殊值以外的地方拆成整段的矩阵的幂和零散区间的，零散区间用线段树维护矩阵积就行了。

##### CF576D Flights for Regular Customers

考虑枚举前 $i$ 条边出现的时候，假设知道了现在可能在哪些地方，可以尝试只用前 $i$ 条边去终点，bfs 一下就行。显然要求某个时刻可能在的地方可以矩阵快速幂加速。

##### CF582D Number of Binominal Coefficients

考虑 $k$ 和 $n-k$ 在 $p$ 进制下相加，每进位一次就会恰好使 $\binom{n}{k}$ 里 $p$ 的个数多 $1$。因此可以 dp 求进位至少 $\alpha$ 次的方案数就行了。

##### CF585E Present for Vitalik the Philatelist 

用 $\mu$ 容斥求出 $\gcd=1$ 的子集个数，然后枚举 $x$，从所有 $\gcd > 1$ 的子集中减去与 $x$ 不互质的子集个数，也用 $\mu$ 容斥。

##### CF585F Digits of Number Pi

直接建 AC 自动机跑 DP。

##### CF590E Birthday

先整个 AC 自动机，然后传递闭包一下，就能求出串之间的包含关系。问题变成最长反链，转成最小链覆盖就行了。

##### CF605E Intergalaxy Trips

每次找出没算的期望时间最小的点算出来就行了。

##### CF634F Orchestra

考虑固定上边界，下边界往下移，维护每一段为左边界时的合法右边界。插入一个的时候只会影响前面 $k$ 段，所以比较暴力地修改就行了。正向做不便于维护，可以倒过来使用链表方便删除。

##### CF639E Bear and Paradox

考虑做题顺序一定是按 $p/t$ 从大到小做，相等的之间可能互换。这样二分 $c$ 以后每个题的最高或最低可能分就很好求了，而判断是否有不合法扫一遍就行了。

##### CF671D Roads in Yusland

考虑从下往上选，贪心选一条当前代价最小的，覆盖这个点到父亲这条边的链。但是这条链可能在之后被其他的链替代，因此要让其他的链都减去这条边的当前代价视作替换的代价。可以用可并堆维护。

##### CF674G Choosing Ads

考虑线性众数那个东西，维护一个数和它的出现次数，遇到不一样的就消去一次。扩展到要求所有出现次数 $\ge 1/k$ 的数上，维护 $k$ 个可能答案，遇到不同的就所有都消去一次，这样也是对的。因此可以线段树维护。

##### CF679E Bear and Bad Powers of 42

线段树直接记一下每个数还差多少到一个次幂，每次 add 完之后有负的就暴力查值改一下，一个位置均摊至多改 $O(log)$ 次。因为还有区间赋值，因此全相同的区间一并操作，势能分析下来复杂度就对了。

##### CF698D Limak and Shooting Points

预处理一个人与一个目标之间的其他目标。考虑爆搜，枚举最后是 $b_i$ 被 $a_j$ 杀，那么这两者之间的目标都要先一步被杀，再枚举谁被谁杀继续往下搜。然而这之间的目标反正都会被杀，没有必要两两枚举，只需要枚举一个固定的目标是被谁杀的就行了。

##### CF700E Cool Slogans

考虑 parent 树上 dp，对于 $x$ 询问 dp 值与其父节点相同的最浅节点是否在 $x$ 出现两次，如果是就能 dp 值 $+1$。写个 right 集合线段树合并查一下就行了。

##### CF704B Ant Man

距离里的绝对值可以化开放到点上，这样代价就只跟一个点的出入边方向有关了。设 $f(i,j)$ 表示前 $i$ 条边，内部连成了 $j$ 条链的方案数，向后转移一个点只需要考虑新点出入边的方向即可。注意 $s$ 和 $e$ 处要特殊处理。

##### CF704D Captain America

很容易对每行每列写出一个某种颜色的个数范围，那么就是横纵坐标的一个有上下界的匹配，跑上下界就行了。

##### CF708D Incorrect Flow

按每条边 $c$ 和 $f$ 的大小关系分类，再讨论一下 $f'$ 的大小求出每种调整的代价和上界，最后跑个类似可行流的费用流就行了。